" Prose (blogging, readmes, any other markdown) configurations
"------------------------

" Setup spell checking, and use <Ctrl>s to open spelling completion menu
au filetype markdown call MarkdownMode()

if exists("+spelllang")
    set spelllang=en_us
endif
set spellfile=~/.vim/spell/en.utf-8.add
command! Onspell set spell
command! Offspell set nospell

nnoremap <LEADER>more i<!--more--><ESC>
nnoremap <leader>gf gqip

function! WrapCurrentWord(format)
  normal! gv
  if a:format == 'bold'
    let wrapping = '**'
  else
    let wrapping = '_'
  endif

  execute 'normal! "ac' . wrapping . 'a' . wrapping
endfunction

vnoremap <C-b> :call WrapCurrentWord("bold")<cr>
vnoremap <C-i> :call WrapCurrentWord("italic")<cr>

function! MarkdownMode()
  " setlocal spell        " Enable spell checking
  setlocal nowrap       " Let long lines scroll off
  setlocal linebreak    " Use word boundaries to break lines
  setlocal textwidth=78
  nnoremap <buffer> <leader>ns ]s
  nnoremap <buffer> <leader>sp ea<C-x><C-s>
  nnoremap <buffer> <leader>sf mm[s1z=`m
  nnoremap <buffer> <LEADER>more i<!--more--><ESC>
  nnoremap <buffer> <leader>gf gqip
  nnoremap <buffer> <leader>md :call OpenCurrentFileInMarked()<cr>
  nnoremap <buffer> <leader>bld mm"bciw**b**<esc>`m2l
  nnoremap <buffer> <leader>em mm"bciw*b*<esc>`m2l
  " Heading / underline funcitons
  nnoremap <buffer> <leader>u1 mmyypVr=`m<cr><esc>
  nnoremap <buffer> <leader>u2 mmyypVr-`m<cr><esc>
  nnoremap <buffer> <leader>u3 mm0i### <esc>`m4l
  command! OpenMarkdownLink call s:OpenLink()
  nnoremap <buffer> <cr> :OpenMarkdownLink<cr>
  nnoremap <buffer> <tab> :JumpToNextLink<cr>
  nnoremap <buffer> <S-tab> :JumpToNextLinkBackward<cr>
  nnoremap <buffer> <leader>fw mm1z=`m
endfunction

function! s:JumpToNextLink(direction)
  " let link_pattern = '\v\[\S.{-}\]\[\]'
  let link_pattern = '\v\[\S.{-}\n?.{-}\]\[\]'
  call s:ShiftCursorColumn(-1) " in case we are currently in a link
  let link_found = search(link_pattern, a:direction)
  if link_found
    nohlsearch
    call s:ShiftCursorColumn(1)
  endif
endfunction
command! JumpToNextLink call <SID>JumpToNextLink('')
command! JumpToNextLinkBackward call <SID>JumpToNextLink('b')

function! s:ShiftCursorColumn(columns)
  let position = getpos('.')[1:3]
  let position[1] += a:columns
  call cursor(position)
endfunction

function! OpenCurrentFileInMarked()
    let current_file = expand('%')
    let open_cmd = join(["open -a Marked", current_file])
    call system(open_cmd)
endfunction

function! ConvertVisualSelectionToLink(...)
    if a:0 == 0
      normal gv"vy
      call s:SearchForTerm()
      return
    else
      let url = a:1
    endif
    normal gv
    normal mm
    execute 'normal! "lc[l][]'
    let current_line = line('.')
    let markdown_h2_pattern = '\v^(\w+.*\n-+|#{2,3}\s+\w+)'
    let next_match_line = search(markdown_h2_pattern)
    if next_match_line == 0 || next_match_line < current_line
      let target_line = line('$')
    else
      let target_line = next_match_line - 2
    endif
    let formatted_link = '[' . @l . ']: ' . url
    call append(target_line, formatted_link)
    call s:EnsureLineAbove(target_line)
    normal `m
endfunction
vnoremap <C-k> :call ConvertVisualSelectionToLink()<cr>

function! s:EnsureLineAbove(target_line)
  if !s:ContentsAreEmptyOrLink(getline(a:target_line))
    call append(a:target_line, '')
  endif
endfunction

function! s:ContentsAreEmptyOrLink(contents)
  let contents_are_link = match(a:contents, '\v\[.*\]:\s')
  return (a:contents == '') || (contents_are_link != -1)
endfunction

function! BumpToPosition(pos)
  let current_line = line('.')
  execute "normal ddgg" . a:pos . "jkP"
  call cursor(current_line, 0)
endfunction
nmap <leader>1 :call BumpToPosition(1)<cr>
nmap <leader>2 :call BumpToPosition(2)<cr>
nmap <leader>3 :call BumpToPosition(3)<cr>
nmap <leader>4 :call BumpToPosition(4)<cr>
nmap <leader>5 :call BumpToPosition(5)<cr>
nmap <leader>6 :call BumpToPosition(6)<cr>
nmap <leader>7 :call BumpToPosition(7)<cr>
nmap <leader>8 :call BumpToPosition(8)<cr>
nmap X mm:call cursor(line('.'), 4)<cr>rx`m

function! s:OpenLink()
  normal mm
  normal "ayi]
  let pattern = '\v^\[' . getreg('a') . '\]: (.*)$'
  let line_num = search(pattern)
  let line = getline(line_num)
  let url = matchlist(line, pattern)[1]
  call system('unsetopt nomatch && open ' . url)
  normal `m
endfunction

function! s:SearchForTerm()
  let search_prompt = "Search term (leave blank to use clipboard): "
  echohl String | let term = input(search_prompt, @v) | echohl None
  if term == ''
    call ConvertVisualSelectionToLink(system('pbpaste'))
    return
  endif
  let encoded_term = webapi#http#encodeURI(term)
  let api_url = 'http://ajax.googleapis.com/ajax/services/search/web?v=1.0&filter=1&rsz=small&q='
  let request_url = api_url . encoded_term
  let response = webapi#http#get(request_url)
  let content = webapi#json#decode(response.content)
  let results = content.responseData.results
  call s:DisplaySearchResults(results)
endfunction

function! s:DisplaySearchResults(results)
  let g:search_results = a:results
  let map_expression = '[v:val.url, "  -> " .v:val.titleNoFormatting, ""]'
  let formatted = Flatten(map(copy(a:results), map_expression))
  silent pedit search-results
  wincmd P
  setlocal buftype=nofile
  setlocal noswapfile
  setlocal nowrap
  nnoremap <buffer> q :q!<cr>
  nnoremap <buffer> <cr> :call SelectSearchResult()<cr>
  nnoremap <buffer> <C-o> :call OpenLinkOnCurrentLine()<cr>
  nnoremap <buffer> <C-n> 2j
  nnoremap <buffer> <C-p> 2k
  normal ggdG
  call append(0, formatted)
  normal ddgg
endfunction

function! OpenLinkOnCurrentLine()
  call system('open ' . expand('<cWORD>'))
endfunction

function! SelectSearchResult()
  let selected = g:search_results[line('.') / 3].url
  bdelete
  call ConvertVisualSelectionToLink(selected)
endfunction

function! Flatten(list)
  let val = []
  for elem in a:list
    if type(elem) == type([])
      call extend(val, Flatten(elem))
    else
      call add(val, elem)
    endif
    unlet elem
  endfor
  return val
endfunction

function! MoveEm(position)
  let zero_indexed_position = a:position - 1
  let save_cursor = getpos(".")
  execute "move " . zero_indexed_position
  call setpos('.', save_cursor)
endfunction

for position in range(1, 9)
  execute "nnoremap m" . position . " :call MoveEm(" . position . ")<cr>"
endfor

function! s:RichTextCopy()
  if expand('%') == ''
    echoerr 'RichTextCopy: File must be saved to disk'
    return
  endif
  if &filetype != 'markdown'
    echoerr 'RichTextCopy: Only valid on filetype "markdown"'
    return
  endif
  if !executable('multimarkdown')
    echoerr 'RichTextCopy: multimarkdown executable required'
    return
  endif
  let rtf_convert_cmd = 'textutil -stdin -stdout -convert rtf -format html'
  let pipeline = ['cat '.expand('%'), 'multimarkdown', rtf_convert_cmd, 'pbcopy']
  call system(join(pipeline, ' | '))
  echohl String | echom 'Document copied as RTF'
endfunction

command! RichTextCopy call <sid>RichTextCopy()

" vim:ft=vim
